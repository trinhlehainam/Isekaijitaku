---
# Forgejo and PostgreSQL Restore Tasks
# 
# This file implements a restore strategy using Docker's native commands for Forgejo and PostgreSQL.
# Key concepts:
# - Checks if backup files exist before restoration
# - Stops all services before restoration begins
# - Removes current data directories to avoid conflicts
# - Restores PostgreSQL database from dump file
# - Unzips and restores Forgejo application data
# - Starts services once restoration is complete
# - Generates detailed restoration report

#################################################
# Initialization and Setup
#################################################

- name: Verify Forgejo backup directory is defined
  ansible.builtin.assert:
    that:
      - forgejo_backup_dir is defined
    fail_msg: "Required variable forgejo_backup_dir is not defined. Please specify the path to the backup directory."

- name: Gather backup directory information
  become: true
  ansible.builtin.stat:
    path: "{{ forgejo_backup_dir }}"
  register: backup_dir_stat

- name: Verify backup directory exists
  ansible.builtin.assert:
    that: backup_dir_stat.stat.exists and backup_dir_stat.stat.isdir
    fail_msg: "Backup directory {{ forgejo_backup_dir }} doesn't exist or is not a directory"

- name: Set up restoration variables
  ansible.builtin.set_fact:
    restore_timestamp: "{{ lookup('pipe', 'date +%Y-%m-%d_%H-%M') }}"
    restore_succeeded: false
    postgres_restore_succeeded: false
    postgres_backup_filename: "forgejo-db-backup.dump"
    forgejo_restore_succeeded: false
    forgejo_backup_filename: "forgejo-app-dump.zip"

- name: Check if existing docker-compose.yml exists
  become: true
  ansible.builtin.stat:
    path: "{{ forgejo_backup_dir }}/docker-compose.yml"
  register: compose_backup_file

- name: Check if existing secrets directory exists
  become: true
  ansible.builtin.stat:
    path: "{{ forgejo_backup_dir }}/secrets"
  register: secrets_backup_dir

- name: Check if PostgreSQL backup file exists
  become: true
  ansible.builtin.stat:
    path: "{{ forgejo_backup_dir }}/{{ postgres_backup_filename }}"
  register: postgres_backup_file

- name: Check if Forgejo backup file exists
  become: true
  ansible.builtin.stat:
    path: "{{ forgejo_backup_dir }}/{{ forgejo_backup_filename }}"
  register: forgejo_backup_file

- name: Verify both backup files exist
  ansible.builtin.assert:
    that:
      - postgres_backup_file.stat.exists
      - forgejo_backup_file.stat.exists
      - compose_backup_file.stat.exists
      - secrets_backup_dir.stat.exists
    fail_msg: "Missing required backup files in {{ forgejo_backup_dir }}."

#################################################
# Project Files Backup and Restoration
#################################################

- name: Backup existing project files with timestamp
  block:
    - name: Check for existing docker-compose.yml file
      ansible.builtin.stat:
        path: "{{ service_project_src }}/docker-compose.yml"
      register: existing_compose_file

    - name: Make sure services are down before restore
      community.docker.docker_compose_v2:
        project_src: "{{ service_project_src }}"
        state: absent
      when: existing_compose_file.stat.exists

    - name: Check for existing secrets directory
      ansible.builtin.stat:
        path: "{{ service_project_src }}/secrets"
      register: existing_secrets_dir

    - name: Create project setup backup folder before restoration
      ansible.builtin.file:
        path: "{{ service_project_src }}/setup_before_restoration/{{ restore_timestamp }}"
        state: directory
        mode: '0755'
      register: setup_backup_result
      when: existing_compose_file.stat.exists or existing_secrets_dir.stat.exists

    - name: Move existing docker-compose.yml file to setup backup
      ansible.builtin.command:
        chdir: "{{ service_project_src }}"
        cmd: mv docker-compose.yml setup_before_restoration/{{ restore_timestamp }}/docker-compose.yml
      when: existing_compose_file.stat.exists
      register: compose_backup_result

    - name: Copy existing secrets directory to setup backup
      become: true
      ansible.builtin.copy:
        src: "{{ service_project_src }}/secrets"
        dest: "{{ service_project_src }}/setup_before_restoration/{{ restore_timestamp }}"
        remote_src: true
      when: existing_secrets_dir.stat.exists
      register: secrets_backup_result

    - name: Remove existing secrets directory
      become: true
      ansible.builtin.file:
        path: "{{ service_project_src }}/secrets"
        state: absent
      when: secrets_backup_result is defined and secrets_backup_result is success

- name: Check for project setup files in backup
  block:
    - name: Restore project setup files from backup
      block:
        - name: Copy docker-compose.yml from backup
          become: true
          ansible.builtin.copy:
            src: "{{ forgejo_backup_dir }}/docker-compose.yml"
            dest: "{{ service_project_src }}/docker-compose.yml"
            remote_src: true
            owner: "{{ ansible_user }}"
            group: "{{ ansible_user }}"
            mode: '0644'
          when: compose_backup_file.stat.exists
          register: compose_restore_result

        - name: Copy secrets directory from backup
          become: true
          ansible.builtin.copy:
            src: "{{ forgejo_backup_dir }}/secrets"
            dest: "{{ service_project_src }}"
            remote_src: true
            owner: "{{ forgejo_user_id }}"
            group: "{{ forgejo_group_id }}"
          when: secrets_backup_dir.stat.exists
          register: secrets_restore_result

#################################################
# Services Management
#################################################

- name: Set restore directory variable
  ansible.builtin.set_fact:
    current_restore_dir: "{{ forgejo_backup_dir }}/restore"

- name: Create restore workspace directory
  become: true
  ansible.builtin.file:
    path: "{{ current_restore_dir }}"
    state: directory
    owner: "{{ ansible_user }}"
    group: "{{ ansible_user }}"
    mode: '0755'

- name: Remove current data directories
  become: true
  ansible.builtin.file:
    path: "{{ item.path }}"
    state: absent
  loop:
    - { path: "{{ forgejo_data_dir }}" }
    - { path: "{{ forgejo_conf_dir }}" }
    - { path: "{{ postgres_data_dir }}" }

#################################################
# Forgejo Application Data Restore
#################################################

- name: Restore Forgejo application data
  block:
    - name: Create temp directory for unzipping
      become: true
      ansible.builtin.file:
        path: "{{ current_restore_dir }}/temp"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      register: temp_unzip_dir
      when: forgejo_backup_file.stat.exists

    - name: Unzip Forgejo backup to temp directory
      become: true
      ansible.builtin.unarchive:
        src: "{{ forgejo_backup_file.stat.path }}"
        dest: "{{ current_restore_dir }}/temp"
        remote_src: true
        owner: "{{ forgejo_user_id }}"
        group: "{{ forgejo_group_id }}"
        mode: '0755'
      register: unzip_result
      when: forgejo_backup_file.stat.exists

    - name: Ensure Forgejo configuration directory exists and has proper ownership
      become: true
      ansible.builtin.file:
        path: "{{ forgejo_conf_dir }}"
        state: directory
        mode: '0755'
        owner: "{{ forgejo_user_id }}"
        group: "{{ forgejo_group_id }}"

    - name: Setup Forgejo restore item variables
      ansible.builtin.set_fact:
        forgejo_restore_items:
          - src: "{{ current_restore_dir }}/temp/app.ini"
            dest: "{{ forgejo_conf_dir }}/app.ini"
            required: true
          - src: "{{ current_restore_dir }}/temp/data"
            dest: "{{ forgejo_data_dir }}"
            required: true
          - src: "{{ current_restore_dir }}/temp/repos"
            dest: "{{ forgejo_data_dir }}/git/repositories"
            required: true
          - src: "{{ current_restore_dir }}/temp/log"
            dest: "{{ forgejo_data_dir }}/data/log"
            required: false
          
    - name: Check Forgejo restore items
      become: true
      ansible.builtin.stat:
        path: "{{ item.src }}"
      loop: "{{ forgejo_restore_items }}"
      loop_control:
        label: "{{ item.src }}"
      when: unzip_result is success
      register: item_stats
      
    - name: Build update list for item restore stats
      ansible.builtin.set_fact:
        update_list: "{{ update_list + update }}"
      loop: "{{ forgejo_restore_items }}"
      loop_control:
        index_var: idx
      vars:
        update_list: []
        item_stat: "{{ item_stats.results | selectattr('item.src', '==', item.src) | first }}"
        update:
          - path: forgejo_restore_items[{{ idx }}].exists
            value: "{{ item_stat.stat.exists if item_stat is defined else false }}"
            
    - name: Make the Forgejo restore items update list
      # https://docs.ansible.com/ansible/latest/collections/ansible/utils/update_fact_module.html
      ansible.utils.update_fact:
        updates: "{{ update_list }}"
      register: updated_result
      
    - name: Verify update result
      ansible.builtin.assert:
        that: "updated_result.failed == false"
        fail_msg: "Failed to update Forgejo restore items"
        success_msg: "Successfully updated Forgejo restore items"

    - name: Update Forgejo restore items
      ansible.builtin.set_fact:
        forgejo_restore_items: "{{ updated_result.forgejo_restore_items }}"
        
    - name: Verify required items exist
      vars:
        missing_required_items: "{{ forgejo_restore_items | selectattr('required', '==', true) | selectattr('exists', '==', false) }}"
      ansible.builtin.assert:
        that: 
          - "missing_required_items | length == 0"
        fail_msg: "Required items missing: {{ missing_required_items | map(attribute='src') | join(', ') }}"
        success_msg: "All required items for Forgejo restoration are available"
        
    - name: Make sure parent directory of forgejo data directory exists
      become: true
      ansible.builtin.file:
        path: "{{ forgejo_data_dir|dirname }}"
        state: directory
        mode: '0755'
        owner: "{{ forgejo_user_id }}"
        group: "{{ forgejo_group_id }}"

    - name: Move Forgejo restore items
      become: true
      ansible.builtin.command: mv "{{ item.src }}" "{{ item.dest }}"
      loop: "{{ forgejo_restore_items }}"
      when: item.exists

    - name: Set correct ownership for Forgejo restore items
      become: true
      ansible.builtin.file:
        path: "{{ item.dest }}"
        owner: "{{ forgejo_user_id }}"
        group: "{{ forgejo_group_id }}"
        recurse: "{{ item.dest == forgejo_data_dir }}"
      loop: "{{ forgejo_restore_items }}"
      loop_control:
        label: "{{ item.dest }}"
      when: item.exists and (item.dest is search('app.ini') or item.dest == forgejo_data_dir)

    - name: Mark Forgejo restoration as successful
      ansible.builtin.set_fact:
        forgejo_restore_succeeded: true

  rescue:
    - name: Record Forgejo restoration failure
      ansible.builtin.set_fact:
        forgejo_restore_error: "{{ ansible_failed_result.msg | default('Unknown error during Forgejo restoration') }}"
        restore_failure_reason: "Forgejo restoration failed: {{ ansible_failed_result.msg | default('Unknown error') }}"

#################################################
# PostgreSQL Database Restore
#################################################

- name: Restore PostgreSQL database
  block:
    - name: Start PostgreSQL container for restoration
      community.docker.docker_compose_v2:
        project_src: "{{ service_project_src }}"
        services: forgejo-db
        state: present
      register: postgres_start_result
      when: postgres_backup_file.stat.exists

    - name: Get PostgreSQL container ID
      ansible.builtin.set_fact:
        postgres_container_id: "{{ (postgres_start_result.containers | selectattr('Service', '==', 'forgejo-db') | first).ID }}"
      when: postgres_start_result is success

    - name: Wait for PostgreSQL to be running and healthy
      when: postgres_container_id is defined
      community.docker.docker_container_info:
        name: "{{ postgres_container_id }}"
      register: postgres_container_info
      failed_when: not postgres_container_info.container.State.Running or postgres_container_info.container.State.Health.Status == 'unhealthy'
      until: postgres_container_info.container.State.Running and postgres_container_info.container.State.Health.Status == 'healthy'
      delay: 5
      retries: 5

    - name: Set PostgreSQL container restore filepath
      ansible.builtin.set_fact:
        postgres_backup_filepath: "{{ forgejo_backup_dir }}/{{ postgres_backup_filename }}"

    - name: Verify restore file exists
      become: true
      ansible.builtin.stat:
        path: "{{ postgres_backup_filepath }}"
      register: postgres_backup_file_stat

    - name: Restore backup file into PostgreSQL container
      become: true
      ansible.builtin.shell:
        chdir: "{{ service_project_src }}"
        cmd: docker compose exec -T forgejo-db pg_restore -U {{ db_user }} -d {{ db_name }} < {{ postgres_backup_filepath }}
      register: postgres_restore_result
      when: postgres_backup_file_stat.stat.exists
      
    - name: Verify PostgreSQL restoration
      ansible.builtin.assert:
        that:
          - postgres_restore_result.rc == 0
        fail_msg: "Failed to restore PostgreSQL database: {{ postgres_restore_result.stderr }}"
        success_msg: "Successfully restored PostgreSQL database"
      
    - name: Mark PostgreSQL restoration as successful
      ansible.builtin.set_fact:
        postgres_restore_succeeded: true
      when:
        - postgres_restore_result is defined
        - postgres_restore_result is success or (postgres_restore_result is failed and postgres_restore_result.stderr is regex('ERROR:  database ".*" does not exist'))

  rescue:
    - name: Record PostgreSQL restoration failure
      ansible.builtin.set_fact:
        postgres_restore_error: "{{ ansible_failed_result.msg | default('Unknown error during PostgreSQL restoration') }}"
        restore_failure_reason: "PostgreSQL restoration failed: {{ ansible_failed_result.msg | default('Unknown error') }}"

#################################################
# Restoration Status and Reporting
#################################################

- name: Set overall restoration success status
  ansible.builtin.set_fact:
    restore_report_path: "{{ forgejo_backup_dir }}/restore/RESTORE_REPORT_{{ restore_timestamp }}.md"
    restore_succeeded: "{{ ((postgres_backup_file.stat.exists and postgres_restore_succeeded) or not postgres_backup_file.stat.exists) and ((forgejo_backup_file.stat.exists and forgejo_restore_succeeded) or not forgejo_backup_file.stat.exists) }}"

- name: Create restoration report
  become: true
  ansible.builtin.copy:
    dest: "{{ restore_report_path }}"
    owner: "{{ ansible_user }}"
    group: "{{ ansible_user }}"
    mode: '0644'
    content: |
      # Forgejo Restoration Report

      **Timestamp:** {{ restore_timestamp }}
      **Backup Source:** {{ forgejo_backup_dir }}
      **Project Directory:** {{ service_project_src }}

      ## Components Status

      | Component | Status | Details |
      |-----------|--------|---------|
      | PostgreSQL | {{ 'SUCCESS ✅' if postgres_restore_succeeded else 'FAILED ❌' }} | {{ postgres_restore_error|default('') if not postgres_restore_succeeded else '' }} |
      | Forgejo | {{ 'SUCCESS ✅' if forgejo_restore_succeeded else 'FAILED ❌' }} | {{ forgejo_restore_error|default('') if not forgejo_restore_succeeded else '' }} |

      {% if forgejo_restore_succeeded and forgejo_restore_items is defined %}
      ## Restored Files Information

      | Component | Source Path | Destination Path | Status |
      |-----------|------------|-----------------|--------|
        {% for item in forgejo_restore_items %}
      | {{ item.src | basename }} | {{ item.src }} | {{ item.dest }} | {{ 'RESTORED ✅' if item.exists else 'MISSING ❌' }} |
        {% endfor %}
      {% endif %}

      ## Summary

      Overall restoration status: {{ 'SUCCESS ✅' if restore_succeeded else 'FAILED ❌' }}
      {% if restore_failure_reason is defined and not restore_succeeded %}
      Error: {{ restore_failure_reason }}
      {% endif %}

      Services will be {{ 'started' if restore_succeeded else 'left down' }} after restoration.

#################################################
# Post-restore Service Management
#################################################

- name: Post successful restore service management
  when: restore_succeeded
  block:
    - name: Start and wait for services to be running and healthy
      ansible.builtin.include_tasks: start.yml

    - name: Display success message
      vars:
        msg: |
          Forgejo has been successfully restored from backup.
          Restoration report saved to {{ restore_report_path }}
      ansible.builtin.debug:
        msg: "{{ msg.split('\n') }}"

    - name: Clean up temporary restore folders
      become: true
      ansible.builtin.file:
        path: "{{ forgejo_backup_dir }}/restore/temp"
        state: absent

    - name: Find most recent backup directory
      become: true
      ansible.builtin.find:
        paths: "{{ forgejo_backup_dir }}"
        file_type: directory
        patterns: "*-*-*_*-*"
      register: timestamp_dirs

- name: Post failed restore service management
  when: not restore_succeeded
  block:
    - name: Build full error message
      ansible.builtin.set_fact:
        error_msg: |
          Forgejo restoration failed!
          Restoration report saved to {{ restore_report_path }}
          Error: {{ restore_failure_reason|default('Unknown error') }}

    - name: Fail when restoration is unsuccessful
      ansible.builtin.fail:
        msg: "{{ error_msg }}"
      when: error_msg is defined