---
##############################################################################
# Forgejo Upgrade Management
##############################################################################
#
# This playbook implements a safe, incremental upgrade process for Forgejo containers.
# It follows these key principles:
#
# 1. SAFETY: Creates backups before any upgrade to ensure rollback capability
# 2. VERIFICATION: Performs version comparison to determine if upgrade is needed
# 3. TRANSPARENCY: Generates detailed reports of both success and failure states
# 4. HEALTH ASSURANCE: Verifies container health after upgrade completion
#
# The upgrade process includes:
# - Current version detection and comparison with target version
# - Configuration backup and preservation
# - Data backup via the standard backup process
# - Container upgrade with proper sequencing
# - Health verification to ensure system stability
# - Detailed reporting for audit and troubleshooting
#
##############################################################################
# Initialization
##############################################################################

- name: Set up Forgejo Rootless project source path
  ansible.builtin.set_fact:
    upgrade_start_time: "{{ ansible_date_time.iso8601 }}"

##############################################################################
# Current Version Analysis
##############################################################################

- name: Check current forgejo container status
  ansible.builtin.include_tasks: check.yml
  
- name: Verify Forgejo container exists
  ansible.builtin.assert:
    that:
      - check_result is defined
      - check_result.services is defined
      - check_result.services | length > 0
    fail_msg: "No existing Forgejo container found for upgrade. Please deploy a new instance first."

- name: Extract current running forgejo image information
  ansible.builtin.set_fact:
    current_forgejo_service: "{{ check_result.services | selectattr('service', 'equalto', 'forgejo') | first }}"
  when: check_result.services | selectattr('service', 'equalto', 'forgejo') | list | length > 0

- name: Verify forgejo service information is available
  ansible.builtin.assert:
    that:
      - current_forgejo_service is defined
      - current_forgejo_service.image is defined
    fail_msg: "Unable to find Forgejo service information in the check results."

- name: Extract current forgejo version
  ansible.builtin.set_fact:
    forgejo_current_image_name: "{{ current_forgejo_service.image }}"
    forgejo_current_image_tag: "{{ current_forgejo_service.image.split(':')[1] if ':' in current_forgejo_service.image else 'latest' }}"

##############################################################################
# Configuration Preservation and Template Management
##############################################################################

# Set required variables for template processing to avoid undefined variable errors
- name: Set default values for template variables
  ansible.builtin.set_fact:
    use_forgejo_mailer: "{{ use_forgejo_mailer | default(false) }}"
    use_forgejo_install_lock: "{{ use_forgejo_install_lock | default(false) }}"
    use_traefik: "{{ use_traefik | default(false) }}"
    use_private_services: "{{ use_private_services | default(false) }}"
    private_services_root_ca: "{{ private_services_root_ca | default(false) }}"
    traefik_router_private: "{{ traefik_router_private | default(false) }}"
    traefik_router_public: "{{ traefik_router_public | default(false) }}"

- name: Copy updated docker-compose template
  ansible.builtin.template:
    src: "docker-compose.yml.j2"
    dest: "{{ forgejo_project_src }}/docker-compose.yml"
    mode: '0644'

- name: Get updated forgejo image from Ansible docker compose template
  ansible.builtin.set_fact:
    forgejo_new_image_full: "{{ (lookup('file', forgejo_project_src + '/docker-compose.yml') | from_yaml | selectattr('service', 'equalto', 'forgejo') | first).image }}"

- name: Get new forgejo version from updated docker-compose template
  when: forgejo_new_image_full is defined
  ansible.builtin.set_fact:
    forgejo_new_image_tag: "{{ forgejo_new_image_full.split(':')[1] if ':' in forgejo_new_image_full else 'latest' }}"

- name: Parse version numbers for comparison
  when: forgejo_new_image_tag is defined
  ansible.builtin.set_fact:
    forgejo_current_version: "{{ forgejo_current_image_tag.split('-')[0].split('.') }}"
    forgejo_new_version: "{{ forgejo_new_image_tag.split('-')[0].split('.') }}"

- name: Determine if new version is greater than current
  when: forgejo_new_image_tag is defined
  ansible.builtin.set_fact:
    version_upgrade_needed: >-
      {{
        (forgejo_new_version[0]|int > forgejo_current_version[0]|int) or 
        (forgejo_new_version[0]|int == forgejo_current_version[0]|int and forgejo_new_version[1]|int > forgejo_current_version[1]|int) or 
        (forgejo_new_version[0]|int == forgejo_current_version[0]|int and forgejo_new_version[1]|int == forgejo_current_version[1]|int and forgejo_new_version[2]|int > forgejo_current_version[2]|int) 
      }}

- name: Set upgrade needed flag for special cases
  when: forgejo_new_image_tag is defined
  ansible.builtin.set_fact:
    upgrade_special_case: "{{ forgejo_current_image_tag != forgejo_new_image_tag and (forgejo_current_image_tag == 'latest' or forgejo_new_image_tag == 'latest' or version_upgrade_needed is not defined) }}"

- name: Set final upgrade flag
  when: forgejo_new_image_tag is defined
  ansible.builtin.set_fact:
    upgrade_needed: "{{ version_upgrade_needed|default(false)|bool or upgrade_special_case|default(false)|bool }}"

- name: Show version comparison
  ansible.builtin.debug:
    msg: 
      - "Current Forgejo version: {{ forgejo_current_image_name }}:{{ forgejo_current_image_tag }}"
      - "New Forgejo version: {{ forgejo_new_image_name }}:{{ forgejo_new_image_tag }}"
      - "Upgrade needed: {{ upgrade_needed|bool }}"
      - "Reason: {{ 'Version upgrade' if version_upgrade_needed|default(false)|bool else 'Tag change' if upgrade_special_case|default(false)|bool else 'No upgrade needed' }}"

##############################################################################
# Upgrade Implementation
##############################################################################

- name: Perform Forgejo upgrade
  when: upgrade_needed|bool
  block:
    - name: Notify user of upgrade status
      ansible.builtin.debug:
        msg: |
          Preparing to upgrade Forgejo from version {{ forgejo_current_image_name }}:{{ forgejo_current_image_tag }} to {{ forgejo_new_image_name }}:{{ forgejo_new_image_tag }}.
          A backup will be performed before proceeding with the upgrade.
    
    #----- Backup Step -----#
    - name: Execute backup before upgrade
      ansible.builtin.include_tasks: backup.yml
      vars:
        operation_mode: "upgrade"
      register: backup_result
    
    #----- Upgrade Step -----#
        #----- Container Management -----#
    - name: Pull updated images
      community.docker.docker_compose_v2:
        project_src: "{{ forgejo_project_src }}"
        pull: "always"
      register: pull_result
      
    - name: Display image pull results
      ansible.builtin.debug:
        msg: "Updated images pulled successfully"
      when: pull_result is defined and pull_result.changed
        
    - name: Stop existing services before starting with new configuration
      community.docker.docker_compose_v2:
        project_src: "{{ forgejo_project_src }}"
        state: absent
      register: stop_result
      
    - name: Verify services stopped successfully
      ansible.builtin.debug:
        msg: "All services stopped successfully for upgrade"
      when: stop_result is defined and stop_result.changed
      
    - name: Start services with new docker-compose configuration
      community.docker.docker_compose_v2:
        project_src: "{{ forgejo_project_src }}"
        state: present
      register: restart_result
      
    - name: Verify services started successfully
      ansible.builtin.debug:
        msg: "Services started with new configuration"
      when: restart_result is defined and restart_result.changed
    
    #----- Service Health Verification -----#
    - name: Wait for services to start up and stabilize
      ansible.builtin.pause:
        seconds: 30
        prompt: "Waiting for services to initialize and achieve healthy state..."
    
    - name: Perform comprehensive container health check
      ansible.builtin.include_tasks: check.yml
    
    - name: Track container status after upgrade
      ansible.builtin.set_fact:
        forgejo_container: "{{ check_result.services | selectattr('service', 'equalto', 'forgejo') | list | first }}"
        db_container: "{{ check_result.services | selectattr('service', 'equalto', 'forgejo-db') | list | first }}"
    
    - name: Verify container runtime state
      ansible.builtin.assert:
        that:
          - forgejo_container.state == 'running'
          - db_container.state == 'running'
        fail_msg: |
          One or more containers failed to start properly after upgrade.
          Forgejo state: {{ forgejo_container.state }}
          Database state: {{ db_container.state }}
    
    - name: Verify container health state
      ansible.builtin.assert:
        that:
          - forgejo_container.health == 'healthy'
          - db_container.health == 'healthy'
          - forgejo_container.image is search(new_image_tag)
        fail_msg: |
          Services failed to reach healthy state after upgrade or new version was not applied correctly.
          Forgejo health: {{ forgejo_container.health }}
          Database health: {{ db_container.health }}
          Image verification: {{ 'OK' if forgejo_container.image is search(new_image_tag) else 'FAILED' }}
    
    #----- Success Report Generation -----#
    - name: Calculate upgrade duration
      ansible.builtin.set_fact:
        upgrade_duration: "{{ 'Unknown' }}"
      changed_when: false
      
    - name: Remove backup docker-compose file on successful upgrade
      ansible.builtin.file:
        path: "{{ docker_compose_backup_path }}"
        state: absent
      when: docker_compose_backup_path is defined and docker_compose_backup.changed
      register: backup_cleanup
    
    - name: Generate comprehensive upgrade success report
      ansible.builtin.set_fact:
        upgrade_report: |
          # Forgejo Upgrade Report
          
          **Timestamp:** {{ ansible_date_time.iso8601 }}
          
          ## Upgrade Summary
          - **Previous Version:** {{ current_image_tag }}
          - **New Version:** {{ new_image_tag }}
          - **Status:** SUCCESS ✅
          - **Duration:** {{ upgrade_duration | default('Unknown') }}
          
          ## Service Health
          - **Forgejo:** {{ 'HEALTHY ✅' if forgejo_container.health == 'healthy' else 'RUNNING ⚠️' }}
          - **PostgreSQL:** {{ 'HEALTHY ✅' if db_container.health == 'healthy' else 'RUNNING ⚠️' }}
          
          ## Configuration
          - **Source Path:** {{ forgejo_project_src }}
          - **Backup Created:** {{ 'Yes' if docker_compose_backup is defined and docker_compose_backup.changed else 'No (not needed)' }}
          - **Backup Cleanup:** {{ 'Yes' if backup_cleanup is defined and backup_cleanup.changed else 'No' }}
          
          Services are now running with the updated version.
          
    - name: Display upgrade success report
      ansible.builtin.debug:
        msg: "{{ upgrade_report.split('\n') }}"
        
    - name: Create upgrade report file
      ansible.builtin.copy:
        dest: "{{ forgejo_project_src }}/UPGRADE_REPORT.md"
        content: "{{ upgrade_report }}"
        mode: '0644'
  rescue:
    #----- Failure Handling -----#
    - name: Calculate upgrade attempt duration
      ansible.builtin.set_fact:
        upgrade_attempt_duration: "{{ 'Unknown' }}"
      changed_when: false
      
    - name: Restore original docker-compose file from backup
      ansible.builtin.command: 
        cmd: "cp {{ docker_compose_backup_path }} {{ forgejo_project_src }}/docker-compose.yml"
      when: docker_compose_backup_path is defined
      register: restore_result
      ignore_errors: true
      
    - name: Report restoration status
      ansible.builtin.debug:
        msg: "{{ 'Successfully restored original docker-compose file' if restore_result is defined and restore_result.rc == 0 else 'Failed to restore docker-compose file from backup' }}"
      when: docker_compose_backup_path is defined
    
    - name: Record detailed upgrade failure information
      ansible.builtin.set_fact:
        upgrade_failure_report: |
          # Forgejo Upgrade Failure Report
          
          **Timestamp:** {{ ansible_date_time.iso8601 }}
          
          ## Upgrade Attempt
          - **From Version:** {{ current_image_tag }}
          - **To Version:** {{ new_image_tag }}
          - **Status:** FAILED ❌
          - **Duration:** {{ upgrade_attempt_duration | default('Unknown') }}
          - **Forced Upgrade:** {{ force_upgrade | default(false) | ternary('Yes', 'No') }}
          
          ## Error Information
          - **Failed Task:** {{ ansible_failed_task.name|default('Unknown error') }}
          - **Error Message:** {{ ansible_failed_result.msg|default('No detailed error message available') }}
          
          ## Environment
          - **Project Directory:** {{ forgejo_project_src }}
          - **Backup Created:** {{ docker_compose_backup is defined and docker_compose_backup.changed | ternary('Yes', 'No') }}
          
          Please check the logs for more details about the failure.
    
    - name: Display upgrade failure report
      ansible.builtin.debug:
        msg: "{{ upgrade_failure_report.split('\n') }}"
        
    - name: Create upgrade failure report file
      ansible.builtin.copy:
        dest: "{{ forgejo_project_src }}/UPGRADE_FAILURE_REPORT.md"
        content: "{{ upgrade_failure_report }}"
        mode: '0644'
        
    - name: Fail task with clear upgrade error message
      ansible.builtin.fail:
        msg: |
          Forgejo upgrade failed. 
          Please see {{ forgejo_project_src }}/UPGRADE_FAILURE_REPORT.md for details.
          Failed task: {{ ansible_failed_task.name|default('Unknown task') }}
